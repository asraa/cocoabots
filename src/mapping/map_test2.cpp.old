#include "map.h"
#include <typeinfo>
#include <cassert>

map::map(std::string filename) {
	maxX = 0;
	maxY = 0;
	res = RES_FIN;
	convFactor = RES_INIT / RES_FIN;
	assert((RES_INIT/RES_FIN) % 2 == 0 || RES_INIT == RES_FIN);

	mapFilename = filename;
	buildMap(mapFilename);
	// do shit
}

void map::buildMap(std::string filename) {
	std::string currentLine;
	std::vector<std::string> tempVector;

	std::ifstream mapFile;
	mapFile.open(filename);

	while (!mapFile.eof()) {
		tempVector.clear();
		getline(mapFile,currentLine);
		std::istringstream iss(currentLine);
		std::string token;
		while (getline(iss, token, ',')) {
			tempVector.push_back(token);
		}

		if (!tempVector.empty()) {
			std::string id = tempVector[0];
			tempVector.erase(tempVector.begin()); // remove 1st elt

			if (id.compare("W") == 0) { 		// WALL
				updateWalls(tempVector);
			}
			else if (id.compare("P") == 0) {	// PLATFORM
				updatePlatforms(tempVector);
			}
			else if (id.compare("S") == 0) {	// STACK
				updateStacks(tempVector);
			}
			else if (id.compare("H") == 0) {	// HOMEBASE
				updateHomeBases(tempVector);
			}
			else if (id.compare("L") == 0) {	// STARTLOC
				updateStartLoc(tempVector);
			}
		}
	}
	mapFile.close();
	std::cout << "close" << std::endl;

	mapVector = createZeroMap(maxX, maxY);
	std::cout << "createZeroMap" << std::endl;

	addHomeBases();
	addStartLoc();
	addStacks();
	addWalls();
	addPlatforms();

	buildMapVector("map.txt");
	std::cout << "writeMapVector" << std::endl;
}

// typedef std::vector<std::tuple<int,int,int,int>> wallItems
// typedef std::vector<std::tuple<int,int,int,int>> platformItems
// typedef std::vector<std::tuple<int,int,int,int,int>> stackItems
// typedef std::vector<std::tuple<int,int>> homeBaseItems;
// typedef std::tuple<int,int> startLocItem

void map::buildMapVector(std::string filename) {
	std::ofstream outFile;
	outFile.open(filename);

	for (int y = 0; y <= maxY; ++y) {
		for (int x = 0; x <= maxX; ++x) {
			outFile << mapVector[x][y];
		}
		outFile << std::endl;
	}

	outFile.close();
}

void map::addWalls() {
	//std::cout << walls.size() << std::endl;
	//std::cout << std::get<0>(walls[12]) << std::endl;
	//std::cout << maxX << " " << maxY << std::endl;
	for (int item = 0; item < walls.size(); ++item) {
		std::cout << item << std::endl;
		int x1 = std::get<0>(walls[item]);
		int y1 = std::get<1>(walls[item]);
		int x2 = std::get<2>(walls[item]);
		int y2 = std::get<3>(walls[item]);
		//std::cout << x1 << " " << y1 << " " << x2 << " " << y2 << std::endl;

		int xsgn, ysgn;
		int deltaX, deltaY, maxDelta;

		deltaX = (x2 - x1);
		deltaY = (y2 - y1);
		xsgn = sign(deltaX);
		ysgn = sign(deltaY);
		maxDelta = std::max(fabs(deltaX),fabs(deltaY));

		for (int i = 0; i <= maxDelta; ++i) {
			int xCoord = x1 + xsgn*i;
			int yCoord = y1 + ysgn*i;
			std::cout << xCoord << " " << yCoord << std::endl;
			writeMapVector(xCoord, yCoord, 1);
		}
	}
}

void map::addPlatforms() {
	for (int item = 0; item < platforms.size(); ++item) {
		int x1 = std::get<0>(platforms[item]);
		int y1 = std::get<1>(platforms[item]);
		int x2 = std::get<2>(platforms[item]);
		int y2 = std::get<3>(platforms[item]);

		int xsgn, ysgn;
		int deltaX, deltaY, maxDelta;

		deltaX = (x2 - x1);
		deltaY = (y2 - y1);
		xsgn = sign(deltaX);
		ysgn = sign(deltaY);
		maxDelta = std::max(fabs(deltaX),fabs(deltaY));

		for (int i = 0; i <= maxDelta; ++i) {
			int xCoord = x1 + xsgn*i;
			int yCoord = y1 + ysgn*i;
			writeMapVector(xCoord, yCoord, 2);
		}
	}
}

void map::addStacks() {
	for (int item = 0; item < stacks.size(); ++item) {
		int xCoord = std::get<0>(stacks[item]);
		int yCoord = std::get<1>(stacks[item]);
		writeMapVector(xCoord, yCoord, 3);
	}
}

void map::addHomeBases() {
	int x1, y1, x2, y2;
	for (int item = 0; item < homeBases.size(); ++item) {
		x1 = std::get<0>(homeBases[item]);
		y1 = std::get<1>(homeBases[item]);

		if (item != homeBases.size()-1) {
			x2 = std::get<0>(homeBases[item+1]);
			y2 = std::get<1>(homeBases[item+1]);
		}
		else {
			x2 = std::get<0>(homeBases[0]);
			y2 = std::get<1>(homeBases[1]);
		}

		int xsgn, ysgn;
		int deltaX, deltaY, maxDelta;

		deltaX = (x2 - x1);
		deltaY = (y2 - y1);
		xsgn = sign(deltaX);
		ysgn = sign(deltaY);
		maxDelta = std::max(fabs(deltaX),fabs(deltaY));

		for (int i = 0; i <= maxDelta; ++i) {
			int xCoord = x1 + xsgn*i;
			int yCoord = y1 + ysgn*i;
			writeMapVector(xCoord, yCoord, 4);
		}
	}
	fillInPolygon(4);
}

void map::addStartLoc() {
	int xCoord = std::get<0>(startLoc);
	int yCoord = std::get<1>(startLoc);	
	writeMapVector(xCoord, yCoord, 5);
}

void map::updateWalls(std::vector<std::string> tempVector) {
	std::string tempString;
	const char* tempChar;
	std::vector<int> tempInts;
	int tempInt;


	for (int i = 0; i < tempVector.size(); ++i) {
		tempString = tempVector[i];
		tempChar = tempString.c_str();
		tempInt = convertInd(std::stoi(tempChar),RES_INIT,RES_FIN);
		std:: cout << "init: " << std::stoi(tempChar) << ", convert: " << tempInt << std::endl;
		tempInts.push_back(tempInt);
	}

	int x1 = tempInts[0];
	int y1 = tempInts[1];
	int x2 = tempInts[2];
	int y2 = tempInts[3];

	updateMaxX(x1);
	updateMaxX(x2);
	updateMaxY(y1);
	updateMaxY(y2);

	std::tuple<int,int,int,int> x1y1x2y2 = std::make_tuple(x1,y1,x2,y2);
	walls.push_back(x1y1x2y2);

}


void map::updatePlatforms(std::vector<std::string> tempVector) {
	std::string tempString;
	const char* tempChar;
	std::vector<int> tempInts;
	int tempInt;


	for (int i = 0; i < tempVector.size(); ++i) {
		tempString = tempVector[i];
		tempChar = tempString.c_str();
		tempInt = convertInd(std::stoi(tempChar),RES_INIT,RES_FIN);
		tempInts.push_back(tempInt);
	}

	int x1 = tempInts[0];
	int y1 = tempInts[1];
	int x2 = tempInts[2];
	int y2 = tempInts[3];

	updateMaxX(x1);
	updateMaxX(x2);
	updateMaxY(y1);
	updateMaxY(y2);

	std::tuple<int,int,int,int> x1y1x2y2 = std::make_tuple(x1,y1,x2,y2);
	platforms.push_back(x1y1x2y2);
}


void map::updateStacks(std::vector<std::string> tempVector) {
	std::string tempString;
	const char* tempChar;
	std::vector<int> tempInts;
	int tempInt;

	for (int i = 0; i < 2; ++i) {
		tempString = tempVector[i];
		tempChar = tempString.c_str();
		tempInt = convertInd(std::stoi(tempChar),RES_INIT,RES_FIN);
		tempInts.push_back(tempInt);
	}

	int x1 = tempInts[0];
	int y1 = tempInts[1];

	updateMaxX(x1);
	updateMaxY(y1);

	//   RED CUBE = 0
	// GREEN CUBE = 1
	//
	// C1->C2->C3
	// BOTTOM->MIDDLE->TOP

	int c1, c2, c3;

	if (tempVector[2].compare("R") == 0) {
		c1 = 0;
	}
	else {
		c1 = 1;
	}
	if (tempVector[3].compare("R") == 0) {
		c2 = 0;
	}
	else {
		c2 = 1;
	}
	if (tempVector[4].compare("R") == 0) {
		c3 = 0;
	}
	else {
		c3 = 1;
	}

	std::tuple<int,int,int,int,int> xyccc = std::make_tuple(x1,y1,c1,c2,c3);
	stacks.push_back(xyccc);
}


void map::updateHomeBases(std::vector<std::string> tempVector) {
	std::string tempString;
	const char* tempChar;
	std::vector<int> tempInts;
	int tempInt;


	for (int i = 0; i < tempVector.size(); ++i) {
		tempString = tempVector[i];
		tempChar = tempString.c_str();
		if (i != 0) {
			tempInt = convertInd(std::stoi(tempChar),RES_INIT,RES_FIN);
		}
		else {
			tempInt = std::stoi(tempChar);
		}
		tempInts.push_back(tempInt);
	}

	int N = tempInts[0];
	std::cout << "got here" << std::endl;
	tempInts.erase(tempInts.begin()); // remove 1st elt

	for (int i = 0; i < N; ++i) {
		int x = tempInts[2*i];
		int y = tempInts[2*i+1];
		updateMaxX(x);
		updateMaxY(y);
		std::tuple<int,int> tempTuple = std::make_tuple(x,y);
		homeBases.push_back(tempTuple);
	}
}


void map::updateStartLoc(std::vector<std::string> tempVector) {
	std::string tempString;
	const char* tempChar;
	std::vector<int> tempInts;
	int tempInt;


	for (int i = 0; i < 2; ++i) {
		tempString = tempVector[i];
		tempChar = tempString.c_str();
		tempInt = convertInd(std::stoi(tempChar),RES_INIT,RES_FIN);
		tempInts.push_back(tempInt);
	}

	int x = tempInts[0];
	int y = tempInts[1];
	updateMaxX(x);
	updateMaxY(y);

	std::tuple<int,int> loc = std::make_tuple(x,y);
	startLoc = loc;
}


void map::updateMaxX(int x) {
	if (x > maxX) {
		maxX = x;
	}
}


void map::updateMaxY(int y) {
	if (y > maxY) {
		maxY = y;
	}
}

gridMap map::createZeroMap(int xDim, int yDim) {
	std::vector<int> tempVector;
	gridMap tempMap;

	// intentionally creating a grid 0->xDim indexed
	// rather than 0->(xDim-1) indexed
	//
	// same for 0->yDim
	//
	// this is because of how staff is doing it.
	//

	for (int x = 0; x <= xDim; ++x) {
		tempVector.clear();
		for (int y = 0; y <= yDim; ++y) {
			tempVector.push_back(0);
		}
		tempMap.push_back(tempVector);
	}
	return tempMap;
}

bool map::isPassable(intTuple pos) {
	return true;
}

int map::sign(int num) {
	if (num > 0) {
		return 1;
	}
	else if (num < 0) {
		return -1;
	}
	else {
		return 0;
	}
}

void map::writeMapVector(int x, int y, int type) {
	int current = mapVector[x][y];
	switch(current) {
		case 0 : mapVector[x][y] = type;
		case 1 : if (type == 2 || type == 3 || type == 5) {
			mapVector[x][y] = type;
		}
		case 2 : if (type == 3 || type == 5) {
			mapVector[x][y] = type;
		}
		case 4 : if (type == 1 || type == 2 || type == 3 || type == 5) {
			mapVector[x][y] = type;
		}
	}
}

void map::fillInPolygon(int type) {
	for (int x = 0; x <= maxX; ++x) {
		for (int y = 0; y <= maxY; ++y) {
			if (checkIfEnclosed(x,y,type)) {
				writeMapVector(x,y,type);
			}
		}
	}
}

bool map::checkIfEnclosed(int x, int y, int type) {
	bool enclosedU, enclosedD, enclosedL, enclosedR = false;

	int yTemp = y;
	while (yTemp >= 0) {
		if (mapVector[x][yTemp] == type) {
			enclosedU = true;
		}
		yTemp -= 1;
	}

	yTemp = y;
	while (yTemp <= maxY) {
		if (mapVector[x][yTemp] == type) {
			enclosedD = true;
		}
		yTemp += 1;
	}

	int xTemp = x;
	while (xTemp != 0) {
		if (mapVector[xTemp][y] == type) {
			enclosedL = true;
		}
		xTemp -= 1;
	}

	xTemp = x;
	while (xTemp <= maxX) {
		if (mapVector[xTemp][y] == type) {
			enclosedR = true;
		}
		xTemp += 1;
	}

	return (enclosedU && enclosedD && enclosedR && enclosedL);
}

int map::convertInd(int ind, int gridResInit, int gridResFin) {
	double indDouble = (double) ind;
	double gridResInitDouble = (double) gridResInit;
	double gridResFinDouble = (double) gridResFin;
	int convertedInd = (int) ((indDouble + 0.5)*gridResInitDouble/gridResFinDouble);
	return convertedInd;
}

double map::indToInch(int ind, int gridRes) {
	return (double) ind*gridRes;
}

int map::inchToInd(double inch, int gridRes) {
	double gridResDouble = (double) gridRes;
	int ind = (int) inch/gridResDouble;
	return ind;
}

int main() {
	map myMap("red_map.txt");
}
